<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just Do It</title>
  
  <subtitle>Every great developer you know got there by solving problems they were unqualified to solve until they actually did it.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.geekiknow.com/"/>
  <updated>2018-06-27T03:43:53.000Z</updated>
  <id>http://www.geekiknow.com/</id>
  
  <author>
    <name>Frio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GNU make使用手册</title>
    <link href="http://www.geekiknow.com/2018/gnu_make_scatch_1/"/>
    <id>http://www.geekiknow.com/2018/gnu_make_scatch_1/</id>
    <published>2018-06-19T02:32:00.000Z</published>
    <updated>2018-06-27T03:43:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们常常使用 make 工具集来决定一个大型程序的哪一块需要被重新编译,然后发起命令来进行重新编译.我们可以将 make 用于任何的语言,只要他们的编译支持shell命令.实际上make的使用也不仅仅受限于程序编译,我们可以将make使用于任何因为其它变化而同时需要自动更新一些文件的场景中去.</p><p>我们需要一个 <em>makefile</em> 来告诉make程序应该做什么, 比如如何编译和进行链接一个程序.比如在对C的程序进行编译的场景中, 当make程序进行重新编译的时候, 每一个变更的C的源文件都应该被重新进行编译, 如果一个头文件发生了变更, 每一个依赖这个头文件的源文件也需要重新编译.每一次编译都会产生一个对象文件object file来对应一个C源文件.最终,当任意一个源文件被重新编译, 所有的对象文件(不管是重新生成的还是上一次的编译所产生的)都要被重新链接操作来产生一个新的可执行的程序.</p><h1 id="makefile中的术语和概念"><a href="#makefile中的术语和概念" class="headerlink" title="makefile中的术语和概念"></a>makefile中的术语和概念</h1><p>一个<em>makefile</em>是由多个”Rule”所组成, 每Rule的结构如下所示:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target … : prerequisites …</span><br><span class="line">        recipe</span><br><span class="line">        …</span><br><span class="line">        …</span><br></pre></td></tr></table></figure><p>下面解释下其中每个术语所对应的含义</p><ul><li>target: 执行所产生的结果文件.我们常常见到的target文件,比如最终的可执行文件或者object 文件.target也可以指代要执行的操作名称, 比如”clean”操作.</li><li>prerequisite: 创建目标文件所需要依赖的文件, 一个目标文件常常需要依赖多个文件.</li><li>recipe: 表示make所需要执行的操作,往往需要多个步骤,可能是一行或者多行的执行命令.需要注意的是,我们需要在每一行要执行的命令前加上tab符号.这里是一个隐晦的约定,如果你不想在头部加上tab符号,可以通过设置.RECIPEPREFIX变量来更改tab为其它符号.</li></ul><p>简单总结成一句话来描述rule,rule就是定义了根据rule中配置的依赖文件, 确定什么时候和如何去做来产生或者更新指定的目标文件. 依赖文件很多时候我们可以不需要, 比如我们定义的clean操作是不需要依赖其它文件的.</p><p>一个<em>makefile</em>文件可能包含其它的文本内容,但是一个简单的makefile只需要包含多个rule就可以了.</p><h2 id="一个简单的makefile"><a href="#一个简单的makefile" class="headerlink" title="一个简单的makefile"></a>一个简单的makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">       insert.o search.o files.o utils.o</span><br><span class="line">        cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">                   insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">        cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">        cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">        cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">        cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">        cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">        cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">        cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">        cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">        rm edit main.o kbd.o command.o display.o \</span><br><span class="line">           insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure><p>根据makefile可见, 我们最终的目标是产出可执行文件edit, edit会依赖8个object文件, 然后这8个object文件同时又会依赖8个源文件和3个头文件,同时文件中使用了 “\” 符号来将很长的一行数据分成多行来进行展示.当我们需要清除目标可执行文件edit和object文件时, 我们可以执行make clean来进行清楚目录下的这些文件.</p><p>在这个例子中, 我们的”target”包含最终的可执行文件”edit”, 对象文件”main.o”和”kbd.o”等等.”prerequisites”包含了”main.c”和头文件”defs.h”等等.实际上, 每一个object文件它们即是target也是prerequisite.”recipes”则包含了”cc -c main.c”和”cc -c kdb.c”等等这些操作.</p><p>recipe应跟随在每一个”target”和”prerequisites”的后面一行.这些recipe用来表达如何更新目标文件.(make无法感知recipe中会做哪些事情,完全依靠你自己来决定提供什么样的recipes, 所有make会做的事情是当目标文件需要发生变更的时候, 执行你定义的这些recipes)</p><p>目标clean不是一个文件, 只是一个操作的名称.因为你不会常常来执行这个操作, 所以clean没有作为其它任何一个rule”prerequisites”, 它不仅没有”prerequistes”, 也会依赖任何”prerequistes”, make在默认执行makefile的时候也不会执行clean中的recipes的内容,除非当你显式地执行 make clean.所以clean这个rule的主要目的是运行指定的recipe(而且是当你明确执行make运行的时候才会运行).</p><h2 id="make程序是如何运行一个makefile的"><a href="#make程序是如何运行一个makefile的" class="headerlink" title="make程序是如何运行一个makefile的"></a>make程序是如何运行一个makefile的</h2><p>默认情况下, make程序会默认开始执行<em>makefile</em>中的第一个rule(target的名称中不带.的).这个Rule被称之为默认的目标.</p><ol><li>make读取了当前文件夹中的makefile</li><li>使用第一个遇到的edit作为默认的执行目标.</li><li>但是当make希望完整的执行完毕这个Rule的时候, 发现这个Rule prerequistes是其它Rule的target.(在这里是其它的object文件)</li><li>开始递归执行edit Rule所依赖的其它的Rule.</li><li>如果其它的Rule不被edit这个Rule所依赖或者递归依赖, 那么就不会被执行(比如clean action)</li><li>每次进行重新编译的时候, make会自行分析(根据依赖情况造成的影响)计算哪些Rule需要重新被执行.比如我们更改了insert.c, 然后再去运行make, 此刻make会重新去编译insert.c, 然后重新执行edit的链接Rule操作.又比如我们更改了, command.h, 那么依赖command.h的这些rule,如kdb.o, command.o, files.o都会被重新执行, 最终重新执行链接操作edit.</li></ol><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">          insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">        cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">        cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">        cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">        cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">        cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">        cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">        cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">        cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">        cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">        rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><h2 id="make-自动推断功能"><a href="#make-自动推断功能" class="headerlink" title="make 自动推断功能"></a>make 自动推断功能</h2><p>其实我们没有必要去告诉 make 如何去编译C的源代码文件, 因为 make 其实可以自己来进行推断. make其实有隐含规则的功能来进行将一个”.c”源文件自动编译成”.o”的对象文件(自动使用命令 cc -c).举例来说, 比如make可以自动将main.c文件进行”cc -c main.c -o main.o”, 因此我不需要再显式地指定target为main.o的recipe,而可以直接使用Rule(只包含target和prerequistes).那么此时简化后的makefile如下所示:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">          insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">        cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">        rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><h3 id="隐式规则-Implicit-Rules"><a href="#隐式规则-Implicit-Rules" class="headerlink" title="隐式规则(Implicit Rules)"></a>隐式规则(Implicit Rules)</h3><p>上面所说的就是隐式规则的一种使用方式.上面我们采用的方式是写一个Rule没有Recipe,实际上我们也可以完全不写这个Rule, 来让make程序来进行自我推断.比如下面这个<em>makefile</em></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo : foo.o bar.o</span><br><span class="line">        cc -o foo foo.o bar.o <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br></pre></td></tr></table></figure><p>我们指定了prerequisit的foo.o和bar.o,但是没有指定foo.o和bar.o是从哪些规则中来的.make就会自动地去寻找自己的implicit rule库, 来自动的生成prerequisite中依赖的文件.</p><p>如果一个隐式规则被找到,它可以自动提供recipe和prerequisites(源文件).每一个隐式规则包含一个target模式和一个prerequisite模式.可能会有很多隐式规则有相同target模式.举个例子,有很多规则都会产生’.o’的目标文件.比如C compiler会从’.c’来编译成’.o’, Pascal compiler会从’.p’产生’.o’文件.规则被选择的前提是,这个隐式规则要求的prerequisites存在或者<strong>可以创建</strong>.所以如果你有一个’.c’的文件, 那么make就会运行C compiler,否则如果你有一个.p的文件,那么make就会运行Pascal compiler.</p><p>通常, make对于下面几种target会默认启动隐式规则搜索:</p><ul><li>只有target和prerequisits的Rule(没有recipe), eg: “abc: test.o”;</li><li>规则中的prerequisits不是任何一个规则的target</li></ul><blockquote><p>上面加粗表示的”可以创建”指的是,当你的隐式规则的prerequisites是另外一个隐式规则的target的时候, 那么这两个隐式规则可以链式的被递归调用.<br>“规则中的prerequisits不是任何一个规则的target”, 这里就会引入一个有趣的问题.比如”foo.o: foo.p”这种情况下, 如果目录下游foo.c的文件, 隐式规则(C compiler编译foo.c-&gt;foo.o)就会被默认采用, 而忽略这里定义的foo.p.因为隐式规则C compiler编译在隐式规则Pascal compiler之前被扫描后采用.</p></blockquote><h2 id="makefile包含的几种事物"><a href="#makefile包含的几种事物" class="headerlink" title="makefile包含的几种事物"></a>makefile包含的几种事物</h2><ul><li>明确的规则.也就是常见的规则</li><li>隐式的规则.前面介绍的隐式规则</li><li>变量定义.前面也有介绍</li><li>指令.告知make做一些较为特别的事情所用<ul><li>读取另外一个makefile</li><li>确定是否使用或者忽略makefile中的一部分内容</li><li>定义一个多行的变量;<a href="https://www.gnu.org/software/make/manual/make.html#Multi_002dLine" target="_blank" rel="noopener">定义方式</a></li></ul></li><li>“#”表示makefile中的注释.如果只是需要”#”字符,只需要在前面加上”#“即可.</li></ul><h3 id="make寻找makefile的方式"><a href="#make寻找makefile的方式" class="headerlink" title="make寻找makefile的方式"></a>make寻找makefile的方式</h3><p>make按照这个顺序来寻找:GNUmakefile(不推荐,只适用于GNU make), makefile, Makefile.如果需要指定费标准名称的makefile,则可以通过选项-f或者–file来使用.</p><h3 id="引用其他的Makefiles"><a href="#引用其他的Makefiles" class="headerlink" title="引用其他的Makefiles"></a>引用其他的Makefiles</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> filenames..</span><br><span class="line"></span><br><span class="line"><span class="section">eg: include foo a.mk b.mk c.mk bish bash</span></span><br></pre></td></tr></table></figure><p>使用include的一个场景是多个不同的程序有各自的makefiles, 但是它们需要共用一套定义的变量或者自定义的隐式规则.另一个场景是当你希望去自动根据源文件来产生prerequisits时使用,prerequisits可以被放置进入一个文件,这个文件又没主的<em>makefile</em>所引用.</p><p>如果引用指定的文件名不是一个绝对路径或者没有在当前文件夹可以被找到,其它的文件夹将会被搜索.首先,通过命令参数”-I”指定的路径会被搜索,然后是/usr/local/include, /usr/gnu/include, /usr/include等等会被使用.</p><h3 id="分析一个实例的makefile文件"><a href="#分析一个实例的makefile文件" class="headerlink" title="分析一个实例的makefile文件"></a>分析一个实例的makefile文件</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PROGRAMNAME=Hello</span><br><span class="line">SOURCES=main.c hello.c</span><br><span class="line"></span><br><span class="line"><span class="comment">#locations</span></span><br><span class="line">SRCDIR=src</span><br><span class="line">OUTDIR=bin</span><br><span class="line">TESTDIR=tests</span><br><span class="line"></span><br><span class="line"><span class="comment"># addprefix 为GNU make的函数, 在后面的参数前添加前缀, 同时将.c的后缀转化为.o的后缀,</span></span><br><span class="line"><span class="comment"># 并将替换掉返回结果赋值于OBJECTS变量,</span></span><br><span class="line">OBJECTS= <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(SRCDIR)</span>/, $(SOURCES:.c=.o)</span>)</span><br><span class="line">PROGRAM= <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(OUTDIR)</span>/, <span class="variable">$(PROGRAMNAME)</span>)</span></span><br><span class="line"></span><br><span class="line">WARNINGS= -W -Wall -ansi -Wextra -pedantic -Wstrict-overflow=5 -Wshadow -Wpointer-arith -Wcast-qual -Wstrict-prototypes <span class="comment"># turn on all possible warnings</span></span><br><span class="line">COMPILER= -std=gnu89 <span class="comment"># -s -march=native -flto -mtune=native -Os -Ofast -ffunction-sections -fdata-sections # strip, optimize for performance and then (mainly) for size. After that place all functions and data to separate sections</span></span><br><span class="line">LINKER= <span class="comment"># -flto -Wl,-Map=$(PROGRAM).map,--cref,--gc-section -Wl,--build-id=none# and with linker delete unneeded ones</span></span><br><span class="line">DEBUG= -g</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> SOURCES</span><br><span class="line"><span class="keyword">export</span> DEBUG</span><br><span class="line"><span class="keyword">export</span> COMPILER</span><br><span class="line"><span class="keyword">export</span> WARNINGS</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(PROGRAM)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: objects clean</span></span><br><span class="line"><span class="section">objects:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(SRCDIR)</span> all</span><br><span class="line"></span><br><span class="line"><span class="variable">$(PROGRAM)</span>: objects</span><br><span class="line">cc -o <span class="variable">$@</span> <span class="variable">$(OBJECTS)</span> <span class="variable">$(DEBUG)</span> <span class="variable">$(LINKER)</span></span><br><span class="line"><span class="comment">#strip -S --strip-all --remove-section=.note.gnu.gold-version --remove-section=.comment --remove-section=.note --remove-section=.note.gnu.build-id --remove-section=.note.ABI-tag $@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(SRCDIR)</span> clean</span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(TESTDIR)</span> clean</span><br><span class="line">rm -f <span class="variable">$(PROGRAM)</span> <span class="variable">$(PROGRAM)</span>.map</span><br></pre></td></tr></table></figure><h3 id="需要打印makefile中的某些变量的值"><a href="#需要打印makefile中的某些变量的值" class="headerlink" title="需要打印makefile中的某些变量的值"></a>需要打印<em>makefile</em>中的某些变量的值</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SOURCES= main.c hello.c</span><br><span class="line"><span class="comment"># $(SOURCES:.c=.o) 含义指后缀替换, 将.c后缀替换为.o后缀</span></span><br><span class="line"><span class="comment"># 使用了GNU make中Substitution References的功能.</span></span><br><span class="line"><span class="comment"># Substitution Reference, form格式: $(var:a=b)</span></span><br><span class="line"><span class="comment"># 取出var的变量值, 将var中每个成员的结尾"a"替换成结尾"b"</span></span><br><span class="line">abc= $(SOURCES:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># @echo 的含义在于当GNU make 在执行recipe的每一行的时候, 都会将这行要执行的命令内容打印出来,加上了@则表示执行此行命令之前, 不要在命令行中输出这行要执行的命令</span></span><br><span class="line"><span class="comment"># $* 表示print-%中'%'匹配的值, 而$(...)则表示取值变量</span></span><br><span class="line">print-%  : ; @echo <span class="variable">$*</span> = $(<span class="variable">$*</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们常常使用 make 工具集来决定一个大型程序的哪一块需要被重新编译,然后发起命令来进行重新编译.我们可以将 make 用于任何的语言,只要他们的编译支持shell命令.实际上make的使用也不仅仅受限于程序编译,我们可以将make使用于任何因为其它变化而同时需要自动更新
      
    
    </summary>
    
    
      <category term="GNU" scheme="http://www.geekiknow.com/tags/GNU/"/>
    
      <category term="make" scheme="http://www.geekiknow.com/tags/make/"/>
    
      <category term="C" scheme="http://www.geekiknow.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Java_SSL详解(二)</title>
    <link href="http://www.geekiknow.com/2018/Java_SSL_2/"/>
    <id>http://www.geekiknow.com/2018/Java_SSL_2/</id>
    <published>2018-06-17T15:42:06.000Z</published>
    <updated>2018-06-19T02:26:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>SSL是一个分层协议并且由4个子协议组成：</p><ul><li>SSL Handshake Protocol</li><li>SSL Change Cipher Spec Protocol</li><li>SSL Alert Protocol</li><li>SSL Record Layer</li></ul><p>层级关系如下图所示：</p><img src="/2018/Java_SSL_2/ssl_01.jpg"><h1 id="SSL的工作方式"><a href="#SSL的工作方式" class="headerlink" title="SSL的工作方式"></a>SSL的工作方式</h1><h2 id="不需要认证客户端的SSL"><a href="#不需要认证客户端的SSL" class="headerlink" title="不需要认证客户端的SSL"></a>不需要认证客户端的SSL</h2><p>在这种场景下，客户端不需要向服务端证明自己的身份。基本上看，客户端可以是任何人，但是客户端和服务端的通信将会是保密的。在这种场景下，客户端不会有它自己的证书。它依靠服务端的证书来进行加密通讯中的消息。请注意我们不是在讨论客户端自己的用户名和密码。Web应用程序仍可能使用用户名和密码来验证用户的身份。这在目前的互联网世界是一件非常普通的事情。举个例子而言，当你访问你银行的网站的时候，并打算去登陆，此时银行并不需要你提供任何证书。下面分几步的来介绍一下当不需要客户端证书的工作步骤：</p><ol><li>服务器向客户端提供服务器证书，客户端用来验证服务器</li><li>客户端生成预主密钥，并使用服务器的公钥对齐进行加密（服务器的公钥是包含在证书之中的），然后将这个预主密钥发送给服务端</li><li>服务端使用私钥将这个预主密钥进行解密</li><li>客户端和服务端根据预主密钥同时计算出来一个主密钥，然后根据这个主密钥产生session keys(session keys用来进行对称加密，在这个SSL会话期内将传递的信息进行加解密并验证数据完整性).</li></ol><p>在这次握手完毕后，服务端和客户端就能以只有各自才知道的密钥进行互相通信。</p><h2 id="需要认证客户端的SSL"><a href="#需要认证客户端的SSL" class="headerlink" title="需要认证客户端的SSL"></a>需要认证客户端的SSL</h2><p>服务端向客户端要求提供证书，以便连接可以互相认证。客户端需要提供自己的证书并使用自己的私钥对握手消息进行签名。这个签名可以通过客户端的证书中的公钥进行验证。这样就可以表示，服务端对私钥有访问的权限。除了这一次的客户端的证书认证，剩余的步骤和上面的 “不需要认证客户端的SSL”都是一致的。在这种类型的沟通中，客户端的用户名和密码用来表示自己身份的方式就是多余的。</p><h2 id="简单的SSL握手图"><a href="#简单的SSL握手图" class="headerlink" title="简单的SSL握手图"></a>简单的SSL握手图</h2><p>这个图展示了简单版的，客户端和服务器之间建立每个SSL连接的步骤。</p><img src="/2018/Java_SSL_2/ssl_01.jpg"><p>正如我们所见，SSL连接的达成始于交换加密参数然后（可选择）认证服务器（使用的是SSL handshake Protocol）。如果握手成功并且双方对于所使用的密码套件和加密的密钥达成一致之后，应用的数据就可以基于一个加密的通道安全的传输了。</p><h2 id="证书内容结构"><a href="#证书内容结构" class="headerlink" title="证书内容结构"></a>证书内容结构</h2><blockquote><p>为了便于理解可以先跳过这一部分，直接去看后面的章节.这里的内容引用自<a href="https://blog.wilddog.com/?p=1185" target="_blank" rel="noopener">作者：王继波 HTTPS通信中的身份认证机制</a>的文章</p></blockquote><p>现在常用的证书类型是X.509, 下面以X.509v3为例，介绍一下证书中的内容。</p><p>X.509v3证书由三部分组成：</p><ul><li>tbsCertificate (to be signed certificate)，待签名证书</li><li>SignatureAlgorithm，签名算法</li><li>SignatureValue，签名值</li></ul><p>tbsCertificate 包含了10项内容，在Https中握手过程中以明文方式进行传输</p><ul><li>Version Number，版本号</li><li>Serial Number，序列号</li><li>Signature Algorithm ID，签名算法ID</li><li>Issuer Name，发行者</li><li>Validity period，有效时间</li><li>Subject name ，证书主体名称</li><li>Subject Public Key Info ，证书主体公钥信息，包含公钥算法和公钥值</li><li>Issuer Unique Identifier (optional)，发行商唯一ID</li><li>Subject Unique Identifier (optional)，主体唯一ID</li><li>Extensions (optional)，扩展</li></ul><p>SignatureAlgorithm签名算法，eg.:(带 RSA 加密的 SHA-256),主要的使用方法就是对tbsCertificate进行哈希后获取消息摘要，再用tbsCertificate中的公钥对签名值进行解密获取摘要，将两个摘要就行比对，判断是否一致，如果一致则认为证书没有被篡改。</p><p>证书链的寻找过程如下图所示：</p><p>客户端访问服务器时，服务器首先返回签名证书，客户端根据签发者的DN往上寻找签发者CA的签名证书，签发者的签名证书会有更高一级的CA的签名证书，以此类推直到找到自签名的ROOT CA证书，看看是否已经处于truststore信任列表，如果是并且通过Public key解密签名值和所计算得出的摘要比对正确后，使用此public key继续对前一层的CA证书做同样的事情。以此类推，最终验证完毕。</p><h1 id="开始试验"><a href="#开始试验" class="headerlink" title="开始试验"></a>开始试验</h1><p>我们将实验的SSL握手将不需要客户端认证。所以我们将准备一个密钥对，服务器的证书。因为我们不进行客户端的认证，所以</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="1-Java-Keytool"><a href="#1-Java-Keytool" class="headerlink" title="1.Java Keytool"></a>1.Java Keytool</h3><p>keytool 是一个私钥和证书管理的工具。它允许用户管理自己的公钥私钥对和相关的证书用于自我认证（用户向其他服务证明自己的身份），或者使用数字签名用于数据完整性校验和认证服务。它还允许用户缓存通讯对等方的公钥（以证书的形式）。Java的发行版中默认提供了这个工具，确保bin目录在你的PATH中。</p><h3 id="2-安装OpenSSL"><a href="#2-安装OpenSSL" class="headerlink" title="2.安装OpenSSL"></a>2.安装OpenSSL</h3><p>SSL社区已经开发了数字证书以及其管理的所有基本工具，也就是OpenSSL.我们要做的也就是去使用这个工具来设置我们的测试认证中心。OpenSSL旨在开发实现一个安全套接字层（SSL v2/v3）和传输安全层（TLS v1）协议的强大的商业级别全功能开源工具包，同时也作为一个全功能的通用加密库。可以去<a href="https://www.openssl.org/" target="_blank" rel="noopener">OpenSSL官网</a>去进行OpenSSL组件的安装。</p><h3 id="3-创建密钥对"><a href="#3-创建密钥对" class="headerlink" title="3.创建密钥对"></a>3.创建密钥对</h3><p>我们将使用keytool来创建密钥对。Java将私钥和证书都放入Key Store中。一个Key Store是由密码保护，且后缀名为JKS的文件。我们使用如下命令来产生一个密钥对：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -alias Deb -keystore DebKeyStore.jks -keyalg RSA -sigalg SHA1withRSA</span><br></pre></td></tr></table></figure><p>创建过程中使用的命令参数解释如下：</p><ul><li>genkey: 产生一个密钥对，并将产生条目放入key store文件中</li><li>alias: 密钥对在key store中对应的简写属性别名</li><li>keystore: 产生的jks文件名为DebKeyStore.jks</li><li>keyalg: 密钥产生算法，最常用的是RSA算法，默认的则是DSA算法</li><li>sigalg: 签名算法，这里“SHA1withRSA”指定的意思是使用SHA1的算法去散列摘要消息并使用RSA的私钥去进行加密。如果私钥对应的算法类型是“DSA”,那么默认的签名算法是SHA1withDSA，如果私钥的算法是”RSA“，那么默认的签名算法是”MD5withRSA”.</li></ul><p>当你运行这个命令的时候，你将会被要求输入两次密码，这两次密码分别对应不同的作用：</p><ol><li><p>Key Store Password: 你可以认为当你输入这个密码后，keytool会将这个密码放入keystore的内容体中，然后对KeyStore的内容散列/摘要产生一个签名，然后将这个签名存入keystore中。如果有人使用密码更改了这个key store文件中的内容，他也没有能力去更新摘要签名的数据。下次当你对这个key store执行keytool的命令的时候，它会发现不匹配的情况，并且警告你不匹配的情况，建议你不要再使用这个key store.</p></li><li><p>Alias Password or Private Key Password: 你将会被要求提供一个条目的密码用来保护alias所对应的条目信息，在这里这个条目的名称是Deb.在这里你可以认为这个密码是用来保护我们产生的private key.这样其它人就没有能力去阅读Deb中private key的内容。</p></li></ol><p>命令执行完毕后，也会要求我们提供DN的信息，在前一章中我们进行了详细的介绍。</p><p>为了确保密钥对正确的加入了key store，我们可以运行下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -list -v -keystore DebKeyStore.jks</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">密钥库类型: JKS</span><br><span class="line">密钥库提供方: SUN</span><br><span class="line"></span><br><span class="line">您的密钥库包含 1 个条目</span><br><span class="line"></span><br><span class="line">别名: deb</span><br><span class="line">创建日期: 2018-6-17</span><br><span class="line">条目类型: PrivateKeyEntry</span><br><span class="line">证书链长度: 1</span><br><span class="line">证书[1]:</span><br><span class="line">所有者: CN=Test, OU=Test, O=Test, L=Test, ST=Test, C=Test</span><br><span class="line">发布者: CN=Test, OU=Test, O=Test, L=Test, ST=Test, C=Test</span><br><span class="line">序列号: 6fe5ac9a</span><br><span class="line">有效期开始日期: Sun Jun 17 11:10:32 CST 2018, 截止日期: Sat Sep 15 11:10:32 CST 2018</span><br><span class="line">证书指纹:</span><br><span class="line"> MD5: 86:2F:0A:21:DF:34:F1:EB:4A:26:BC:8C:D2:02:D9:4C</span><br><span class="line"> SHA1: 86:64:14:CA:F3:AA:E9:BF:96:F1:89:2F:0B:74:C1:0A:E2:53:54:E8</span><br><span class="line"> SHA256: 91:D5:A7:31:B7:47:23:98:ED:95:DE:EA:40:54:50:5B:62:5E:62:5C:C4:9B:95:00:18:66:0D:7D:24:81:DE:0A</span><br><span class="line"> 签名算法名称: SHA1withRSA</span><br><span class="line"> 版本: 3</span><br><span class="line"></span><br><span class="line">扩展:</span><br><span class="line"></span><br><span class="line">#1: ObjectId: 2.5.29.14 Criticality=false</span><br><span class="line">SubjectKeyIdentifier [</span><br><span class="line">KeyIdentifier [</span><br><span class="line">0000: 31 8B EB 48 9A 37 5F 35   B0 B2 AC B6 69 4A 15 D7  1..H.7_5....iJ..</span><br><span class="line">0010: A5 90 2B 2D                                        ..+-</span><br><span class="line">]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*******************************************</span><br><span class="line">*******************************************</span><br></pre></td></tr></table></figure><p>当执行这个命令的时候，keytool会向你要求提供key store的密码来验证文件的内容的完整性。如果你不想输入密码，那么可以采用-proteced的参数，这样你可以看到key store的内容，但是无法获知完整性的校验结果。注意keytool不会打印出来私钥或者公钥，它只会告知key store中有一个私钥条目。</p><h3 id="4-自签名的证书"><a href="#4-自签名的证书" class="headerlink" title="4.自签名的证书"></a>4.自签名的证书</h3><p>现在我们的key store中已经有了一个私钥和一个公钥。Key Store不是一个数字证书，他只是一个保存证书和私钥的商店。现在让我们导出包含着（public key）的证书。使用下面这个命令来导出证书：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -export -alias Deb -file Deb.cer -keystore DebKeyStore.jks</span><br></pre></td></tr></table></figure><p>现在Deb.cer已经是一个拥有着公钥的证书。现在让我们打印这个证书的内容来看一看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -printcert -v -file Deb.cer</span><br></pre></td></tr></table></figure><blockquote><p>使用keytool你无法导出私钥.如果想导出私钥，你需要使用Java Cryptography API.</p></blockquote><p>Deb.cer 是一个自签名的证书。他的所有者和发布者都是有着相同的DN.这个证书是由Deb的私钥来进行签名。</p><h3 id="5-创建一个CSR"><a href="#5-创建一个CSR" class="headerlink" title="5.创建一个CSR"></a>5.创建一个CSR</h3><p>此刻你已经拥有了一个有着密钥对的key store,即: DebKeyStore.jks 和一个包含着你的公钥的和DN信息的自签名的cer证书。但是浏览器此时还是不会信任你！只是有一个自签名的证书是不够的！为了被信任，你需要将你的证书再由CA进行签名才可以。为了做到这一点，你还需要生成一个Certificate Signing Request(CSR)，然后将这个文件发送给CA机构来进行签名。keytool产生csr文件的方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -certreq -alias Deb -keystore DebKeyStore.jks -file Deb.csr</span><br></pre></td></tr></table></figure><p>上面这个命令会从jks文件中提取出来需要的信息，如公钥，DN，然后将其放入一个标准格式的csr文件中。商业CA机构在使用他们的签名签发证书之前会验证所有提供的信息。</p><h3 id="6-创建一个测试的CA机构"><a href="#6-创建一个测试的CA机构" class="headerlink" title="6.创建一个测试的CA机构"></a>6.创建一个测试的CA机构</h3><p>首先我们需要创建测试CA的私钥。这个是CA的高度机密，如果这个发生了泄露，那么CA就不再可信了，所有这个CA机构颁发的证书就应该被回收。对于我们的测试CA,我们需要创建密钥对并为我们的CA的公钥创建证书签名请求。请注意，这里的CSR是为了我们CA自己。这两步可以通过下面一个命令办到:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -keyout cakey.pem -out careq.pem</span><br></pre></td></tr></table></figure><p>每个命令参数的解释：</p><ul><li>req: 用于certificate siging requst(CSR)</li><li>new: 创建一个新的私钥和一个csr</li><li>keyout: 将private key放入文件cakey.pem.(高度机密文件)</li><li>out: 将CSR写入careq.pem</li></ul><p>当我们在执行命令的时候，它需要我们提供相关DN信息并需要一个密码来加密我们的private key.</p><blockquote><p>可以看到我们在上面的章节中使用keytool做了类似的事情，实际上我们也可以使用openssl来做到同样的事情。</p></blockquote><p>现在我们可以对我们上面生成过的CSR来进行签名了，显然这将是自签名的。下面的Openssl命令将根据CSR来产生一个自签名的证书。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -signkey cakey.pem -req -days 3650 -in careq.pem -out caroot.cer -extensions v3_ca</span><br></pre></td></tr></table></figure><ul><li>x509: 使用X.509证书</li><li>signkey: 使用cakey.pem中的私钥来生成自签名的证书</li><li>req: 告知input是一个CSR</li><li>days: 指定生成的证书的有效期</li><li>in: 指定输入csr文件路径</li><li>out: 指定输出证书的文件路径</li></ul><p>此刻我们已经CA有了一个自签名的根证书。这个证书将和私钥一道来签名其他的证书。这个根证书应该公开可用，并且必须要被浏览器和应用程序所信任。我们可以使用keytool来进行打印这个证书文件的内容.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytotol -printcert -v -file caroot.cer</span><br></pre></td></tr></table></figure><p>我们下一步可以手工让我们的浏览器来信任我们自己创建的CA的证书。Java运行环境将CA证书存储在 ${JAVA_HOME}/lib/security/cacerts文件中。这是一个keystore文件，我们可以使用keytool命令来查看其中的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -list -protected -keystore cacerts</span><br></pre></td></tr></table></figure><p>我们也可以将这个CA证书加入cacerts文件中， caerts的keystore文件的默认密码是”changeit”.我们也可以将这个Test CA证书添加进入我们的DebKeyStore.jks文件中，在运行时指向这个key store,以便我信任们使用这个CA颁发的证书。</p><h3 id="7-使我们创建的证书被我们创建的CA所签名"><a href="#7-使我们创建的证书被我们创建的CA所签名" class="headerlink" title="7.使我们创建的证书被我们创建的CA所签名"></a>7.使我们创建的证书被我们创建的CA所签名</h3><p>现在Test CA已经准备完毕，我们也已经将其假如我们浏览器信任的truststore.现在是时候使用这个CA证书来签名我们前面创建的签名证书了。然而，在CA在进行颁发一个证书的时候，需要写一串序列号进行这个证书里面去，所以你需要告诉Openssl下一个序列号应该使用什么值。所以我们需要创建一个serial.txt来包含序列号的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 1234&gt;serial.txt</span><br><span class="line">openssl x509 -CA caroot.cer -CAkey cakey.pem -CAserial serial.txt -req -in Deb.csr -out DebTestCA.cer -days 365</span><br></pre></td></tr></table></figure><h3 id="8-Java中导入CA证书和被CA签名的证书"><a href="#8-Java中导入CA证书和被CA签名的证书" class="headerlink" title="8.Java中导入CA证书和被CA签名的证书"></a>8.Java中导入CA证书和被CA签名的证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">keytool -import -alias TestCA -file caroot.cer -keystore DebKeyStore.jks</span><br><span class="line"></span><br><span class="line">keytool -list -v -keystore DebKeyStore.jks</span><br><span class="line"></span><br><span class="line">密钥库类型: JKS</span><br><span class="line">密钥库提供方: SUN</span><br><span class="line"></span><br><span class="line">您的密钥库包含 2 个条目</span><br><span class="line"></span><br><span class="line">别名: deb</span><br><span class="line">创建日期: 2018-6-17</span><br><span class="line">条目类型: PrivateKeyEntry</span><br><span class="line">证书链长度: 2</span><br><span class="line">证书[1]:</span><br><span class="line">所有者: CN=Test, OU=Test, O=Test, L=Test, ST=Test, C=Test</span><br><span class="line">发布者: EMAILADDRESS=fantasycool@126.com, CN=test, OU=test, O=test, L=test, ST=test, C=zh</span><br><span class="line">序列号: 1235</span><br><span class="line">有效期开始日期: Sun Jun 17 16:42:11 CST 2018, 截止日期: Mon Jun 17 16:42:11 CST 2019</span><br><span class="line">证书指纹:</span><br><span class="line"> MD5: 06:CB:4C:DB:6B:D2:39:A1:B3:C2:54:27:87:4E:76:A7</span><br><span class="line"> SHA1: 29:1F:DF:15:06:FA:C5:2E:EC:FE:E7:18:C1:0B:28:E4:53:25:A2:54</span><br><span class="line"> SHA256: 85:E5:DC:C1:01:DE:C8:9D:4A:07:F6:60:EF:4F:4D:E9:2C:DD:C3:D7:E1:13:F8:E4:51:7B:77:F2:0C:EA:82:73</span><br><span class="line"> 签名算法名称: SHA1withRSA</span><br><span class="line"> 版本: 1</span><br><span class="line">证书[2]:</span><br><span class="line">所有者: EMAILADDRESS=fantasycool@126.com, CN=test, OU=test, O=test, L=test, ST=test, C=zh</span><br><span class="line">发布者: EMAILADDRESS=fantasycool@126.com, CN=test, OU=test, O=test, L=test, ST=test, C=zh</span><br><span class="line">序列号: ecec5d0c5300b823</span><br><span class="line">有效期开始日期: Sun Jun 17 16:37:54 CST 2018, 截止日期: Wed Jun 14 16:37:54 CST 2028</span><br><span class="line">证书指纹:</span><br><span class="line"> MD5: AD:48:CB:E8:19:31:DF:B4:BD:DF:94:C1:FF:4E:88:4D</span><br><span class="line"> SHA1: A9:DA:E3:1A:47:6B:71:70:80:65:73:B9:02:FA:CF:77:26:ED:93:74</span><br><span class="line"> SHA256: 44:A3:21:9A:40:A6:97:81:88:DF:3A:A4:56:F4:B3:85:F7:94:84:00:B4:B3:9E:76:12:1A:97:54:75:2E:D5:50</span><br><span class="line"> 签名算法名称: SHA1withRSA</span><br><span class="line"> 版本: 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*******************************************</span><br><span class="line">*******************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">别名: testca</span><br><span class="line">创建日期: 2018-6-17</span><br><span class="line">条目类型: trustedCertEntry</span><br><span class="line"></span><br><span class="line">所有者: EMAILADDRESS=fantasycool@126.com, CN=test, OU=test, O=test, L=test, ST=test, C=zh</span><br><span class="line">发布者: EMAILADDRESS=fantasycool@126.com, CN=test, OU=test, O=test, L=test, ST=test, C=zh</span><br><span class="line">序列号: ecec5d0c5300b823</span><br><span class="line">有效期开始日期: Sun Jun 17 16:37:54 CST 2018, 截止日期: Wed Jun 14 16:37:54 CST 2028</span><br><span class="line">证书指纹:</span><br><span class="line"> MD5: AD:48:CB:E8:19:31:DF:B4:BD:DF:94:C1:FF:4E:88:4D</span><br><span class="line"> SHA1: A9:DA:E3:1A:47:6B:71:70:80:65:73:B9:02:FA:CF:77:26:ED:93:74</span><br><span class="line"> SHA256: 44:A3:21:9A:40:A6:97:81:88:DF:3A:A4:56:F4:B3:85:F7:94:84:00:B4:B3:9E:76:12:1A:97:54:75:2E:D5:50</span><br><span class="line"> 签名算法名称: SHA1withRSA</span><br><span class="line"> 版本: 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*******************************************</span><br><span class="line">*******************************************</span><br></pre></td></tr></table></figure><p>分析一下上面的打印信息，我们可以发现这里就是一条证书链。也就是当我们进行服务端的身份验证的时候，根据证书1，我们发现发布者为“<a href="mailto:EMAILADDRESS=fantasycool@126.com" target="_blank" rel="noopener">EMAILADDRESS=fantasycool@126.com</a>, CN=test, OU=test, O=test, L=test, ST=test, C=zh”，说明我们这个证书被一个CA所签名认证，那我们就向上寻找所有者为“<a href="mailto:EMAILADDRESS=fantasycool@126.com" target="_blank" rel="noopener">EMAILADDRESS=fantasycool@126.com</a>, CN=test, OU=test, O=test, L=test, ST=test, C=zh”的签名证书，结果找到了所有者和发布者相同的签名证书，说明此时已经为最上层的根证书了，假如我们此时已经信任了这个根证书，那么就可以反向沿着证书链来不断重新生成消息摘要，比对签名值来进行验证，以此类推。</p><h3 id="9-准备好程序所有需要的key-store文件"><a href="#9-准备好程序所有需要的key-store文件" class="headerlink" title="9.准备好程序所有需要的key store文件"></a>9.准备好程序所有需要的key store文件</h3><p>在前面我们创造的DevKeyStore.jks,里面包含了私钥和证书，现在我们会使用这个DevKeyStore.jks来作为我们的服务端key store,拷贝重命名为ServerKeyStore.jks.虽然我们不需要客户端的证书认证，但是我们仍然需要为请求的客户端准备一个keystore,用来添加Test CA’s的根证书。因为如果我们是通过浏览器来访问，可以通过手工添加证书到浏览器来做到信任。但是假如通过Java程序来访问，我们则需要在程序中信任配置这个根证书。使用下面这个命令来创建ClientKeyStore.jks.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">keytool -import -keystore ClientKeyStore.jks -alias testca -file caroot.cer</span><br><span class="line"></span><br><span class="line">输入密钥库口令:</span><br><span class="line">再次输入新口令:</span><br><span class="line">所有者: EMAILADDRESS=fantasycool@126.com, CN=test, OU=test, O=test, L=test, ST=test, C=zh</span><br><span class="line">发布者: EMAILADDRESS=fantasycool@126.com, CN=test, OU=test, O=test, L=test, ST=test, C=zh</span><br><span class="line">序列号: ecec5d0c5300b823</span><br><span class="line">有效期开始日期: Sun Jun 17 16:37:54 CST 2018, 截止日期: Wed Jun 14 16:37:54 CST 2028</span><br><span class="line">证书指纹:</span><br><span class="line"> MD5: AD:48:CB:E8:19:31:DF:B4:BD:DF:94:C1:FF:4E:88:4D</span><br><span class="line"> SHA1: A9:DA:E3:1A:47:6B:71:70:80:65:73:B9:02:FA:CF:77:26:ED:93:74</span><br><span class="line"> SHA256: 44:A3:21:9A:40:A6:97:81:88:DF:3A:A4:56:F4:B3:85:F7:94:84:00:B4:B3:9E:76:12:1A:97:54:75:2E:D5:50</span><br><span class="line"> 签名算法名称: SHA1withRSA</span><br><span class="line"> 版本: 1</span><br><span class="line">是否信任此证书? [否]:  是</span><br><span class="line">证书已添加到密钥库中</span><br></pre></td></tr></table></figure><p>最后，贴上Java的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.frio.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ServerSocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLServerSocket;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLServerSocketFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EchoServer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"javax.net.ssl.keyStore"</span>, <span class="string">"/tmp/ServerKeyStore.jks"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"javax.net.ssl.keyStorePassword"</span>, <span class="string">"111111"</span>);</span><br><span class="line"></span><br><span class="line">        System.setProperty(<span class="string">"javax.net.debug"</span>, <span class="string">"ssl:record"</span>);</span><br><span class="line"></span><br><span class="line">        EchoServer server = <span class="keyword">new</span> EchoServer();</span><br><span class="line">        server.startServer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketFactory ssf = SSLServerSocketFactory.getDefault();</span><br><span class="line">        SSLServerSocket serverSocket = (SSLServerSocket)ssf.createServerSocket(<span class="number">8282</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket client = serverSocket.accept();</span><br><span class="line">            <span class="keyword">new</span> ProcessRequest(client);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * InnerEchoServer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessRequest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        Socket client;</span><br><span class="line">        BufferedReader is;</span><br><span class="line">        DataOutputStream out;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ProcessRequest</span><span class="params">(Socket s)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.client = s;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                is = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</span><br><span class="line">                out = <span class="keyword">new</span> DataOutputStream(client.getOutputStream());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String request = is.readLine();</span><br><span class="line">                System.out.println(<span class="string">"Received from client:"</span> + request);</span><br><span class="line">                out.writeBytes(<span class="string">"HTTP/1.0 200 OK\r\n"</span>);</span><br><span class="line">                out.writeBytes(<span class="string">"Content-Type: text/html\r\n"</span>);</span><br><span class="line">                out.writeBytes(<span class="string">"ok:"</span>+request);</span><br><span class="line">                out.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">client.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.frio.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocket;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EchoClient</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"javax.net.ssl.trustStore"</span>, <span class="string">"/tmp/ClientKeyStore.jks"</span>);</span><br><span class="line">        System.setProperty(<span class="string">"java.net.debug"</span>, <span class="string">"ssl:record"</span>);</span><br><span class="line"></span><br><span class="line">        SSLSocketFactory f = (SSLSocketFactory) SSLSocketFactory.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SSLSocket c = (SSLSocket)f.createSocket(<span class="string">"localhost"</span>, <span class="number">8282</span>);</span><br><span class="line">            c.startHandshake();</span><br><span class="line">            </span><br><span class="line">            BufferedWriter w = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(c.getOutputStream()));</span><br><span class="line">            BufferedReader r = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(c.getInputStream()));</span><br><span class="line">            </span><br><span class="line">            String message = <span class="string">"Hey, here is the client, how are you!"</span>;</span><br><span class="line">            w.write(message, <span class="number">0</span>, message.length());</span><br><span class="line">            w.newLine();</span><br><span class="line">            w.flush();</span><br><span class="line"></span><br><span class="line">            String m = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span>((m = r.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(m);</span><br><span class="line">            &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文汇总翻译<a href="https://sites.google.com/site/ddmwsst/create-your-own-certificate-and-ca/ssl-socket-communication" target="_blank" rel="noopener">SSL Socket Communication</a>和<a href="https://sites.google.com/site/ddmwsst/create-your-own-certificate-and-ca" target="_blank" rel="noopener">Create Your Own Certificate and CA</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SSL是一个分层协议并且由4个子协议组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SSL Handshake Protocol&lt;/li&gt;
&lt;li&gt;SSL Change Cipher Spec Protocol&lt;/li&gt;
&lt;li&gt;SSL Alert Protocol&lt;/li&gt;
&lt;li&gt;S
      
    
    </summary>
    
    
      <category term="Java" scheme="http://www.geekiknow.com/tags/Java/"/>
    
      <category term="SSL" scheme="http://www.geekiknow.com/tags/SSL/"/>
    
      <category term="Openssl" scheme="http://www.geekiknow.com/tags/Openssl/"/>
    
      <category term="KeyStore" scheme="http://www.geekiknow.com/tags/KeyStore/"/>
    
  </entry>
  
  <entry>
    <title>Java_SSL详解(一)</title>
    <link href="http://www.geekiknow.com/2018/Java_SSL_1/"/>
    <id>http://www.geekiknow.com/2018/Java_SSL_1/</id>
    <published>2018-06-15T14:53:06.000Z</published>
    <updated>2018-06-19T02:26:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你需要从CA机构获取SSL的证书,你就必须创建一个证书认证请求(Certificate Signing Request, CSR).CSR主要包含的内容是一个公钥和一些额外的信息,当这个CSR被CA机构所认证后,这两个信息都会被写入证书中(也就是.cer文件中).</p><p>当你在创建CSR文件的时候,会被要求提供关于创建证书所需要的一些信息.就是我们熟知的Distinguised Name(DN).DN中比较重要的一个属性是CommonName(CN), 也就是打算使用该域名的确切完全的限定域名(FQDN). 录入的方式不仅仅限于交互提示的命令行的方式, 也可以使用直接在一行命令中提供信息或者是文件来提供信息的方式.</p><p>DN中其它的信息则是放置关于你的网站的组织和公司的信息.如果你是从一个权威的CA认证机构来购买的的SSL证书, 这些信息往往是需要详细去提供的.</p><h3 id="产生CSR的方式"><a href="#产生CSR的方式" class="headerlink" title="产生CSR的方式"></a>产生CSR的方式</h3><h4 id="如果你已经有了一个私钥-此时你需要向一个CA请求一个证书-可以使用下面这个命令"><a href="#如果你已经有了一个私钥-此时你需要向一个CA请求一个证书-可以使用下面这个命令" class="headerlink" title="如果你已经有了一个私钥,此时你需要向一个CA请求一个证书,可以使用下面这个命令"></a>如果你已经有了一个私钥,此时你需要向一个CA请求一个证书,可以使用下面这个命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl req \</span><br><span class="line">       -key domain.key \</span><br><span class="line">       -new -out domain.csr</span><br></pre></td></tr></table></figure><p>根据命令行的提示,一步步补充所需信息.</p><blockquote><p>-key的option配置表示一个存在private.key的文件地址.-new的option配置表示这里会重新产生一个新的CSR文件.</p></blockquote><h4 id="如果你需要续订现有的证书-但是CA或者你自己又没有保存之前的CSR文件-此时你需要重新生成一个CSR文件-可以使用下面这种办法"><a href="#如果你需要续订现有的证书-但是CA或者你自己又没有保存之前的CSR文件-此时你需要重新生成一个CSR文件-可以使用下面这种办法" class="headerlink" title="如果你需要续订现有的证书,但是CA或者你自己又没有保存之前的CSR文件,此时你需要重新生成一个CSR文件, 可以使用下面这种办法"></a>如果你需要续订现有的证书,但是CA或者你自己又没有保存之前的CSR文件,此时你需要重新生成一个CSR文件, 可以使用下面这种办法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 \</span><br><span class="line">       -in domain.crt \</span><br><span class="line">       -signkey domain.key \</span><br><span class="line">       -x509toreq -out domain.csr</span><br></pre></td></tr></table></figure><blockquote><p>-x509toreq表示正在使用X509证书来创建一个CSR</p></blockquote><h4 id="如果你需要使用SSL证书来加密你的服务-但是你又不需要CA进行签名认证的证书-最简单的办法是自己来进行签名-可以使用下面这种办法"><a href="#如果你需要使用SSL证书来加密你的服务-但是你又不需要CA进行签名认证的证书-最简单的办法是自己来进行签名-可以使用下面这种办法" class="headerlink" title="如果你需要使用SSL证书来加密你的服务,但是你又不需要CA进行签名认证的证书, 最简单的办法是自己来进行签名, 可以使用下面这种办法**"></a>如果你需要使用SSL证书来加密你的服务,但是你又不需要CA进行签名认证的证书, 最简单的办法是自己来进行签名, 可以使用下面这种办法**</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl req \</span><br><span class="line">       -newkey rsa:2048 -nodes -keyout domain.key \</span><br><span class="line">       -x509 -days 365 -out domain.crt</span><br></pre></td></tr></table></figure><p>这个命令创建了一个2048-bit的私钥, 和一个自签名的domain.crt. -x509选项表示表示告诉 req 创建一个自签名的证书, -days 365 表示这个证书将在365天内是有效的. 一个临时的CSR文件同时也会产生用来存储和证书相关联的信息.</p><h4 id="直接通过一个私钥来生成一个自签名的证书"><a href="#直接通过一个私钥来生成一个自签名的证书" class="headerlink" title="直接通过一个私钥来生成一个自签名的证书"></a>直接通过一个私钥来生成一个自签名的证书</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl req \</span><br><span class="line">       -key domain.key \</span><br><span class="line">       -new \</span><br><span class="line">       -x509 -days 365 -out domain.crt</span><br></pre></td></tr></table></figure><p>x509 选项告诉 req 需要创建一个自签名的证书, -new 表示交互式的方式来填充CSR所需要的信息.</p><h4 id="通过一个已有的私钥和CSR文件来生成自签名的证书"><a href="#通过一个已有的私钥和CSR文件来生成自签名的证书" class="headerlink" title="通过一个已有的私钥和CSR文件来生成自签名的证书"></a>通过一个已有的私钥和CSR文件来生成自签名的证书</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 \</span><br><span class="line">       -signkey domain.key \</span><br><span class="line">       -in domain.csr \</span><br><span class="line">       -req -days 365 -out domain.crt</span><br></pre></td></tr></table></figure><h3 id="查看证书"><a href="#查看证书" class="headerlink" title="查看证书"></a>查看证书</h3><p>证书和CSR都是以PEM格式进行编码的, 这种格式没法被人直接阅读.所以对于CSR, CRT的文件需要进行工具函数的转化.</p><h4 id="阅读CSR内容"><a href="#阅读CSR内容" class="headerlink" title="阅读CSR内容"></a>阅读CSR内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -text -noout -verify -in domain.csr</span><br></pre></td></tr></table></figure><h4 id="阅读证书的内容"><a href="#阅读证书的内容" class="headerlink" title="阅读证书的内容"></a>阅读证书的内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -text -noout -in domain.crt</span><br></pre></td></tr></table></figure><h4 id="判断一个证书是否由一个CA所签发-ca-crt是CA机构的证书"><a href="#判断一个证书是否由一个CA所签发-ca-crt是CA机构的证书" class="headerlink" title="判断一个证书是否由一个CA所签发(ca.crt是CA机构的证书)"></a>判断一个证书是否由一个CA所签发(ca.crt是CA机构的证书)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl verify -verbose -CAFile ca.crt domain.crt</span><br></pre></td></tr></table></figure><h3 id="Private-Keys相关"><a href="#Private-Keys相关" class="headerlink" title="Private Keys相关"></a>Private Keys相关</h3><h4 id="创建一个2048-bit由密码保护的private-key"><a href="#创建一个2048-bit由密码保护的private-key" class="headerlink" title="创建一个2048-bit由密码保护的private key"></a>创建一个2048-bit由密码保护的private key</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -des3 -out domain.key 2048</span><br></pre></td></tr></table></figure><h4 id="判断-private-key-是不是一个合法的-key"><a href="#判断-private-key-是不是一个合法的-key" class="headerlink" title="判断 private key 是不是一个合法的 key"></a>判断 private key 是不是一个合法的 key</h4><p>如果是一个有密码的私钥, 则会有提示输入密码.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -check -in domain.key</span><br></pre></td></tr></table></figure><h4 id="判断private-key和crt文件-csr文件是否为相关联的关系"><a href="#判断private-key和crt文件-csr文件是否为相关联的关系" class="headerlink" title="判断private key和crt文件, csr文件是否为相关联的关系"></a>判断private key和crt文件, csr文件是否为相关联的关系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -noout -modulus -in domain.key | openssl md5</span><br><span class="line">openssl x509 -noout -modulus -in domain.crt | openssl md5</span><br><span class="line">openssl req -noout -modulus -in domain.csr | openssl md5</span><br></pre></td></tr></table></figure><p>如果这三个输出的值是相等的,则私钥,crt,csr这三者之前的相关联的关系非常高</p><h4 id="加解密private-key"><a href="#加解密private-key" class="headerlink" title="加解密private key"></a>加解密private key</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -des3 \</span><br><span class="line">       -in unencrypted.key \</span><br><span class="line">       -out encrypted.key</span><br><span class="line"></span><br><span class="line">openssl rsa \</span><br><span class="line">       -in encrypted.key \</span><br><span class="line">       -out decrypted.key</span><br></pre></td></tr></table></figure><h3 id="改变证书的格式"><a href="#改变证书的格式" class="headerlink" title="改变证书的格式"></a>改变证书的格式</h3><p>到目前为止我们在使用的X.509证书的编码格式是ASCII PEM编码的方式.有很多其它种的编码格式或者容器的类型.有一些应用更偏重于特定的格式,并且所有这些另外的格式会包含多个条目, 比如证书, private key, CA证书包含在一个文件之中.Openssl可以被用来将证书的不同格式进行互相转换.</p><h4 id="将PEM转化成DER"><a href="#将PEM转化成DER" class="headerlink" title="将PEM转化成DER"></a>将PEM转化成DER</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 \</span><br><span class="line">       -in domain.crt \</span><br><span class="line">       -outform der -out domain.der</span><br></pre></td></tr></table></figure><h4 id="将DER转化为PEM"><a href="#将DER转化为PEM" class="headerlink" title="将DER转化为PEM"></a>将DER转化为PEM</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 \</span><br><span class="line">       -inform der -in domain.der \</span><br><span class="line">       -out domain.crt</span><br></pre></td></tr></table></figure><h4 id="将PEM转化为PKCS7"><a href="#将PEM转化为PKCS7" class="headerlink" title="将PEM转化为PKCS7"></a>将PEM转化为PKCS7</h4><p>下面这个命令的作用是将签名证书domain.crt和CA证书链打包成一个PKCS7 文件(domain.p7b).PKCS7 文件, 也就是P7B文件, 常常被使用与java KeyStores和Microsoft IIS. 他们都是包含签名后证书和CA证书的ASCII文件.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl crl2pkcs7 -nocrl \</span><br><span class="line">       -certfile domain.crt \</span><br><span class="line">       -certfile ca-chain.crt \</span><br><span class="line">       -out domain.p7b</span><br></pre></td></tr></table></figure><h4 id="将PEM转化成PKCS12"><a href="#将PEM转化成PKCS12" class="headerlink" title="将PEM转化成PKCS12"></a>将PEM转化成PKCS12</h4><p>将私钥和签名证书打包转化成PKCS12文件(domain.pfx).我们也可将ca.crt文件打包进入PKCS12文件中,通过将ca.crt的文件内容添加进入domain.crt文件中.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 \</span><br><span class="line">       -inkey domain.key \</span><br><span class="line">       -in domain.crt \</span><br><span class="line">       -export -out domain.pfx</span><br></pre></td></tr></table></figure><h3 id="将PKCS12转化为PEM"><a href="#将PKCS12转化为PEM" class="headerlink" title="将PKCS12转化为PEM"></a>将PKCS12转化为PEM</h3><p>将domain.pfx文件转化为crt文件.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 \</span><br><span class="line">       -in domain.pfx \</span><br><span class="line">       -nodes -out domain.combined.crt</span><br></pre></td></tr></table></figure><h3 id="如何抓取一个网站的Https签名证书"><a href="#如何抓取一个网站的Https签名证书" class="headerlink" title="如何抓取一个网站的Https签名证书"></a>如何抓取一个网站的Https签名证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl s_client -connect www.baidu.com:443</span><br></pre></td></tr></table></figure><blockquote><p>注意: 因为pfx里面可能包含私钥,证书文件,ca.crt文件, 所以PEM文件中会统一包含所有的内容(这也是称之为domain.combined.crt的原因).<br>证书格式分类章内容翻译自作者<br><a href="https://www.digitalocean.com/community/tutorials/openssl-essentials-working-with-ssl-certificates-private-keys-and-csrs" target="_blank" rel="noopener">Mitchell Anicas文章OpenSSL Essentials: Working with SSL Certificates, Private Keys and CSRs</a></p></blockquote><h2 id="Java如何使用SSL"><a href="#Java如何使用SSL" class="headerlink" title="Java如何使用SSL"></a>Java如何使用SSL</h2><p>SSL提供了2个设备之间通过网络安全通信的连接.主要为了达成以下几个目标:</p><ul><li>加密: 保护各方之间的数据传输,保证隐私性</li><li>认证: 确保我们连接的服务器就是我们所认为的服务器</li><li>数据完整性: 确保收到的请求数据就是发出的数据(数据在传输过程中没有被替换)</li></ul><p>Java提供了几种安全API框架来帮助保障开发者达成上面这三个目标</p><ul><li>Java Secured-Socket Extension (JSSE)</li><li>Java Crytopgraphy Architecture (JCA)</li><li>Java Crytographic Extension (JCE)</li></ul><h3 id="Java-keytool-和-OpenSSL工具的区别"><a href="#Java-keytool-和-OpenSSL工具的区别" class="headerlink" title="Java keytool 和 OpenSSL工具的区别"></a>Java keytool 和 OpenSSL工具的区别</h3><blockquote><p>参考stackoverflow: <a href="https://security.stackexchange.com/questions/98282/difference-between-openssl-and-keytool" target="_blank" rel="noopener">Difference between OpenSSL and keytool</a><br>参考<a href="https://www.digitalocean.com/community/tutorials/java-keytool-essentials-working-with-java-keystores" target="_blank" rel="noopener">Java Keytool Essentials: Working with Java Keystores</a></p></blockquote><p>keytool和Openssl工具的共同点在于, 它们的目标都是为了创建/保存私钥和证书(证书链).Java语言只能处理JKS格式的文件(同时包含了证书和私钥).类似JKY格式的文件的场景是在openssl中所创建的PKCS12(.p12)格式的文件(这也是一个由密码保护的容器包含了私钥和证书),但是.p12格式是不兼容于.jks文件的, Java程序也无法处理, 所以需要将.p12转化成.jks, 这样Java才能进行处理.</p><h3 id="创建KeyStore中的条目"><a href="#创建KeyStore中的条目" class="headerlink" title="创建KeyStore中的条目"></a>创建KeyStore中的条目</h3><h4 id="在KeyStore中创建或者更新私钥"><a href="#在KeyStore中创建或者更新私钥" class="headerlink" title="在KeyStore中创建或者更新私钥"></a>在KeyStore中创建或者更新私钥</h4><p>如果你需要HTTPS来保护你的应用, 下面这个命令将创建一个密钥对, 可以用来创建CSR, 并且从CA中获得签名证书. 命令将产生一个2048-bit的RSA私钥对, 挂在条目domain下, 并存于keystore.jks文件中, 如果keystore.jks的这个文件不存在,则会自动进行创建.命令执行后, 会自动提示输入保护密码和相关DN信息的设置.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkeypair \</span><br><span class="line">        -alias domain \</span><br><span class="line">        -keyalg RSA \</span><br><span class="line">        -keystore keystore.jks</span><br></pre></td></tr></table></figure><h4 id="导入签名过的证书-CA证书-链-进入jks文件"><a href="#导入签名过的证书-CA证书-链-进入jks文件" class="headerlink" title="导入签名过的证书/CA证书(链)进入jks文件"></a>导入签名过的证书/CA证书(链)进入jks文件</h4><p>比如你需要导入一个CA机构签名认证过的证书进入keystore文件中, 那么这个签名过的证书文件必须和jks文件中的私钥相匹配.也可以使用相同的命令导入CA的根证书或者中间CA证书,以完成CA证书的信任链(只需要将domain替换成root即可, 还有指定你要导入的ca证书文件).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keytool -importcert \</span><br><span class="line">        -trustcacerts -file domain.crt \</span><br><span class="line">        -alias domain \</span><br><span class="line">        -keystore keystore.jks</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用同样的命令将CA证书导入java 默认的 truststore($JAVA_HOME/jre/lib/security/cacerts), 也可以直接生成一个新的truststore, 不过这个truststore中只有你导入的要信任的CA证书.下面列出一段只信任某个根证书的代码:</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.http-client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>google-http-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.23.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -import -file ~/Documents/GlobalSign\ Root\ CA.cer -alias globalSignCA -keystore trustStore</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpsTrustTool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException, GeneralSecurityException</span>&#123;</span><br><span class="line">        FileInputStream myKeys = <span class="keyword">new</span> FileInputStream(<span class="string">"/tmp/trustStore"</span>);</span><br><span class="line">        KeyStore myTrustStore = KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">        myTrustStore.load(myKeys, <span class="string">"123456"</span>.toCharArray());</span><br><span class="line"></span><br><span class="line">        NetHttpTransport netHttpTransport = <span class="keyword">new</span> NetHttpTransport.Builder().trustCertificates(myTrustStore).build();</span><br><span class="line">        HttpRequestFactory requestFactory = netHttpTransport.createRequestFactory();</span><br><span class="line"></span><br><span class="line">        HttpRequest request = requestFactory.buildGetRequest(<span class="keyword">new</span> GenericUrl(<span class="string">"https://u-api.alibaba-inc.com"</span>));</span><br><span class="line">        String rawResponse = request.execute().parseAsString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看Keystore中的内容"><a href="#查看Keystore中的内容" class="headerlink" title="查看Keystore中的内容"></a>查看Keystore中的内容</h3><h4 id="罗列jks文件中所有证书的指纹"><a href="#罗列jks文件中所有证书的指纹" class="headerlink" title="罗列jks文件中所有证书的指纹"></a>罗列jks文件中所有证书的指纹</h4><p>展示keystore.jks中的所有的签名的指纹, 并按照它们各自alias名称进行展示, 执行命令时也会被要求提供对应的密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keytool -list \</span><br><span class="line">        -keystore keystore.jks</span><br><span class="line"></span><br><span class="line">// 对于只需要展示一个alias别名对应的证书时</span><br><span class="line">keytool -list -keystore -alias domain keystore.jks</span><br></pre></td></tr></table></figure><h4 id="罗列jks文件中所有证书更详尽的信息"><a href="#罗列jks文件中所有证书更详尽的信息" class="headerlink" title="罗列jks文件中所有证书更详尽的信息"></a>罗列jks文件中所有证书更详尽的信息</h4><p>下面的命令会罗列出keystore中每一个条目的信息, 包含证书链的长度, 证书链中证书的指纹, DN信息， serial number, 创建和过期的时间等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keytool -list -v \</span><br><span class="line">        -keystore keystore.jks</span><br><span class="line"></span><br><span class="line">// 比如罗列 $JAVA_HOME/jre/lib/security/cacerts的证书详细信息</span><br></pre></td></tr></table></figure><h4 id="罗列某一个签名后的证书的信息"><a href="#罗列某一个签名后的证书的信息" class="headerlink" title="罗列某一个签名后的证书的信息"></a>罗列某一个签名后的证书的信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keytool -printcert \</span><br><span class="line">        -file domain.crt</span><br></pre></td></tr></table></figure><h3 id="更新KeyStore文件内容"><a href="#更新KeyStore文件内容" class="headerlink" title="更新KeyStore文件内容"></a>更新KeyStore文件内容</h3><h4 id="更改KeyStore文件的密码"><a href="#更改KeyStore文件的密码" class="headerlink" title="更改KeyStore文件的密码"></a>更改KeyStore文件的密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keytool -storepasswd \</span><br><span class="line">        -keystore keystore.jks</span><br></pre></td></tr></table></figure><h4 id="删除KeyStore文件中某个别名的条目"><a href="#删除KeyStore文件中某个别名的条目" class="headerlink" title="删除KeyStore文件中某个别名的条目"></a>删除KeyStore文件中某个别名的条目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keytool -delete \</span><br><span class="line">        -alias domain \</span><br><span class="line">        -keystore keystore.jks</span><br></pre></td></tr></table></figure><h4 id="更改KeyStore文件中某个条目的别名"><a href="#更改KeyStore文件中某个条目的别名" class="headerlink" title="更改KeyStore文件中某个条目的别名"></a>更改KeyStore文件中某个条目的别名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keytool -changealias \</span><br><span class="line">        -alias domain \</span><br><span class="line">        -destalias newdomain \</span><br><span class="line">        -keystore keystore.jks</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果你需要从CA机构获取SSL的证书,你就必须创建一个证书认证请求(Certificate Signing Request, CSR).CSR主要包含的内容是一个公钥和一些额外的信息,当这个CSR被CA机构所认证后,这两个信息都会被写入证书中(也就是.cer文件中).&lt;/p
      
    
    </summary>
    
    
      <category term="Java" scheme="http://www.geekiknow.com/tags/Java/"/>
    
      <category term="SSL" scheme="http://www.geekiknow.com/tags/SSL/"/>
    
      <category term="Openssl" scheme="http://www.geekiknow.com/tags/Openssl/"/>
    
      <category term="KeyStore" scheme="http://www.geekiknow.com/tags/KeyStore/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置文件全剖析</title>
    <link href="http://www.geekiknow.com/2018/nginx_config/"/>
    <id>http://www.geekiknow.com/2018/nginx_config/</id>
    <published>2018-06-12T14:06:18.000Z</published>
    <updated>2018-06-14T05:36:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx作为目前最常使用的异步框架Web服务器, 我们常常将它使用在反向代理， 负载均衡， Http缓存等应用场景。在使用Nginx的时候，我们不可避免地需要去变更NGINX的配置文件来实现我们想要的功能。对于不是很熟悉NGINX配置文件结构的人， 在打开NGINX配置文件的时候， 往往会比较茫然，不是很明白如何正确快速的入手去配置， 今天我们从NGINX的配置文件结构上进行剖析，来掌握好NGINX配置文件的经络结构， 这样后续我们在配置NGINX的时候就能更快更高效达到我们的目标。</p><h2 id="配置文件目录位置"><a href="#配置文件目录位置" class="headerlink" title="配置文件目录位置"></a>配置文件目录位置</h2><p>Nginx的主配置文件是nginx.conf, 它的目录位置根据安装nginx方式的不同也是不同的，我们常常可以在以下几个位置可以找到它。</p><ul><li>/etc/nginx/nginx.conf</li><li>/usr/local/nginx/conf/nginx.conf</li><li>/usr/local/etc/nginx/nginx.conf</li></ul><h2 id="上下文配置的概念"><a href="#上下文配置的概念" class="headerlink" title="上下文配置的概念"></a>上下文配置的概念</h2><p>Nginx的主配置文件是以类似树状的结构来进行组织的， 可以看到由多个“{}”包裹的配置块组装而成。在Nginx的术语中， 这些块被称之为“上下文”。每个块中包含了各自所关注场景下一些配置信息，这些上下文配置配置整体组装起来后，为Nginx提供了一个整体配置结构，并提供了一些逻辑条件帮助NGINX来判断确定在何种情况下使用其中的配置。</p><p>因为上下文之间可以分层嵌套，NGINX提供了指令继承配置的功能。在更大配置上下文作用域中的声明的配置指令，这个配置指令的默认值将被嵌套其中的子上下文作用域所默认继承，不过子上下文可以根据需要进行重新配置这个默认继承的配置指令值覆盖掉这个默认值的配置。</p><p>一些配置只能使用在一些特定类型的上下文配置中，Nginx在进行启动的时候如果发现一些配置指令配置在了错误类型的上下文中的时候，Nginx会打印出错误日志。对于什么类型的上下文配置中应该包含哪些配置，可以参考<a href="http://nginx.org/en/docs/dirindex.html" target="_blank" rel="noopener">Nginx的配置文档</a>。</p><h2 id="核心上下文配置"><a href="#核心上下文配置" class="headerlink" title="核心上下文配置"></a>核心上下文配置</h2><h3 id="主上下文配置（Main-Context）"><a href="#主上下文配置（Main-Context）" class="headerlink" title="主上下文配置（Main Context）"></a>主上下文配置（Main Context）</h3><p>先看下Nginx.conf一段配置内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user www-data;</span><br><span class="line">worker_processes auto;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">        worker_connections 768;</span><br><span class="line">        # multi_accept on;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到前三行配置，并不属于任何一个“{}”上下文块中，像这种独立于“{}“块的配置我们统一称之为主上下文配置（Main Context）。主配置的配置内容通常表示Nginx的整体的环境变量配置，这里主要放置会影响NGINX应用运行的基础配置。在这里放置的配置很多时候会向下影响到子上下文的配置，但是其中很多的配置不会被继承到，因为这些配置不能被覆盖。</p><blockquote><p>主上下文配置通常是系统级别的全局配置，如下是几个常见的栗子：</p><ol><li>运行worker进程的用户和组配置</li><li>运行worker的数量配置</li><li>保存主进程的PID文件配置</li><li>调整CPU affinity 和 Worker进程niceness的值</li><li>整个应用默认异常文件配置（可被更具体的上下文配置覆盖）</li></ol></blockquote><h3 id="事件上下文配置（Event-Context）"><a href="#事件上下文配置（Event-Context）" class="headerlink" title="事件上下文配置（Event Context）"></a>事件上下文配置（Event Context）</h3><p>事件上下文配置是被包含在主上下文配置中的。它通常的配置是用来设置Nginx如何在一般级别情况下处理连接。注意整个Nginx配置文件中只允许出现一个事件上下文配置。事件上下文配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user www-data;</span><br><span class="line">worker_processes auto;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">        worker_connections 768;</span><br><span class="line">        # multi_accept on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nginx进行连接处理时使用的是基于异步事件驱动的模型，所以在这里的上下文进行的配置是用来决定worker进程如何处理连接。在这里常见的配置是选择合适的事件驱动模型，比如我们常见的epoll, select等。其它的配置如： worker可以处理的连接数，以及当被通知有打开的连接时， 一个worker是否一次只取一个连接，还是一次性取出所有打开的连接，worker是否采用轮流的方式来响应事件。</p><h3 id="HTTP上下文配置-（Http-Context）"><a href="#HTTP上下文配置-（Http-Context）" class="headerlink" title="HTTP上下文配置 （Http Context）"></a>HTTP上下文配置 （Http Context）</h3><p>当我们把Nginx作为一个Web服务器和一个反向代理服务器的时候，这里的配置会是我们最常改动的位置。Http上下文配置包含了所有配置指令和其它类型的所必须的上下文配置， 这里的配置用来定义NGINX如何处理HTTP和HTTPS的请求。</p><p>HTTP上下文配置为事件上下文配置的兄弟节点，所以它们之间并非嵌套关系，而是并列关系。它们都是主上下文配置的儿子节点。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # Basic Settings</span><br><span class="line">        ##</span><br><span class="line"></span><br><span class="line">        sendfile on;</span><br><span class="line">        tcp_nopush on;</span><br><span class="line">        tcp_nodelay on;</span><br><span class="line">        keepalive_timeout 65;</span><br><span class="line">        types_hash_max_size 2048;</span><br><span class="line">        # server_tokens off;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>同时HTTP上下文配置中嵌套的更底层的上下文配置则会配置更具体详细的控制如何控制请求，在这个层级中的配置指令用来控制每一个virtual server(也就是server上下文配置， 后文会有介绍)上下文配置所会继承的默认配置值。在这个上下文配置以及其中嵌套的子上下文配置中有着大量的配置指令，依赖于你如何去选择要去被继承的指令配置。</p><p>HTTP上下文你最有可能会去变更的包含下列几种类型的配置：</p><ul><li>access_log和error_log的路径配置</li><li>配置文件处理的异步I/O机制（aio, sendfile, directio）</li><li>当错误发生的时候，Server的状态fanhui，比如错误页面的地址</li><li>压缩相关的配置（gzip和gzip_disable）</li><li>调试TCP keep alive的配置（keepalive_disable, keepalive_requests, keepalive_timeout）</li><li>包处理和系统调用优化配置（sendfile, tcp_nodelay, tcp_nopush）</li><li>剩余其它的配置等:<ul><li>NGINX整个应用级别访问的根目录配置和首页配置（root、index）</li><li>用来存储不同类型数据（server_names, types, variables）不同hash table配置的选择（<em>_hash_bucket_size, </em>_hash_max_size）</li><li>等等</li></ul></li></ul><blockquote><p>aio, sendfile, directio 这几个是在做优化场景中会采取的手法，也是面试中会经常被问到的问题，后续会出专题分开介绍。</p></blockquote><h3 id="Server上下文配置（Server-Context）"><a href="#Server上下文配置（Server-Context）" class="headerlink" title="Server上下文配置（Server Context）"></a>Server上下文配置（Server Context）</h3><p>Server上下文配置是嵌套于前面所说的Http上下文配置之中的配置， 这也是我们到现在讲述的第一个”嵌套型”上下文配置， 这也是第一个可以声明多次的上下文配置。配置结构如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    # http context</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"></span><br><span class="line">        # first server context</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"></span><br><span class="line">        # second server context</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>允许声明多个Server上下文配置实例的原因是，我们希望更精确的控制请求连接，每一个Server上下文配置块会对应一个虚拟的Server来负责一部分连接，你可以根据不同的需求来任意配置多个Server上下文。</p><p>正是因为并列的多个Server上下文配置的存在，当一个客户端请求发起请求到Nginx的时候，Nginx应该根据这多个Server上下文的配置来选择出一个最贴近此请求特征细节的Server配置实例，并按照这个Server上下文配置的来进行处理这个请求。特征细节主要包含两个方面：</p><ul><li>监听（listen）：这个Server上下文配置的会用来处理哪些ip和端口。如果一个请求过来，它的来源ip和访问的端口和这里的配置能够很好的匹配，那么这个Server上下文的配置实例就会被选上作为候选。</li><li>服务名称（server name）: 如果有多个Server上下文实例的listen都匹配上了，此时Nginx会去解析请求中的header头，并用这个header头来进行匹配操作。</li></ul><p>Server上下文中的很多配置指令会覆盖在Http上下文配置中的指令，比如包括日志的，文档root配置，压缩配置等等。除了使用来自Http上下文的配置指令之外，我们还可以进行配置相应请求的try_files配置，重定向的配置（rewrite,return)等等，设置变量值。</p><h3 id="Location上下文配置（Location-Context）"><a href="#Location上下文配置（Location-Context）" class="headerlink" title="Location上下文配置（Location Context）"></a>Location上下文配置（Location Context）</h3><p>location 的配置如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location match_modifier location_match &#123;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下location在nginx文档中的说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax:location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125;</span><br><span class="line">location @name &#123; ... &#125;</span><br><span class="line">Default:—</span><br><span class="line">Context:server, location</span><br></pre></td></tr></table></figure><blockquote><p>locations是根据request请求uri进行的设置。匹配发生在将“%xx”格式的uri解码, 解析完相对路径“.”和”..”, 将相邻”/“斜线转化成一个”/“等操作之后。location的匹配定义有两种方式， 前缀匹配和正则匹配。正则匹配的制定方式是使用“~*”（大小写不敏感）或者”~”（大小写敏感）的标识符。在确定一个Location和一个请求相匹配时，nginx首先会去查验前缀匹配模式定义的location，在这些location上下文配置里面，nginx会找出匹配最长的location的上下文配置进行选择和记录，然后，NGINX再会去查验正则匹配的locations上下文配置，按照这些location上下文配置在配置文件中出现的顺序，一个个地进行正则匹配。搜索会在第一个匹配到时终止，相应的location配置会被采用。如果没有找到对应的正则表达式的location配置，前面进行前缀匹配满足的location上下文配置记录会被选择作为要被使用的location配置。</p></blockquote><p>locations上下文配置和server上下文配置由很多相似的地方。比如，location上下文配置可以被定义多个，并且每一个location配置处理单独一种特定类型的请求，并且通过一个特定的选则算法，可以将一个特定的Location上下文配置和客户端的请求进行匹配起来。</p><p>和server上下文配置的不同点在于，location上下文配置是嵌套于Server上下文配置中的，并且location上下文之间可以互相嵌套。嵌套的特性可以帮助我们更容易抽象请求的分类处理，比如我们可以先定义一个更笼统的location上下文配置来圈定一种类型的请求，在这种类型的请求中我们可以使用嵌套的方式再做进一步的子集类型的细分，创建额外多个不同的location上下文配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// main context</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">    # server context</span><br><span class="line"></span><br><span class="line">    location /match/criteria &#123;</span><br><span class="line"></span><br><span class="line">        # first location context</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /other/criteria &#123;</span><br><span class="line"></span><br><span class="line">        # second location context</span><br><span class="line"></span><br><span class="line">        location nested_match &#123;</span><br><span class="line"></span><br><span class="line">            # first nested location</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location other_nested &#123;</span><br><span class="line"></span><br><span class="line">            # second nested location</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，server上下文的配置选择是基于请求的ip和port结合请求头中的Host属性，location则通过请求的URI地址进一步地细分请求的URI.请求的URI内容对应的是域名或者IP地址以及端口号后面的那部分内容.</p><p>所以，当一个客户端发起请求 <a href="http://www.example.com:80/blog" target="_blank" rel="noopener">http://www.example.com:80/blog</a> 的时候，http, <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>, 80 用来决定选择哪一个server，当server被选择后，/blog则被用来选择哪个location会被匹配到用来做更进一步的请求的处理。</p><h2 id="其它的上下文配置"><a href="#其它的上下文配置" class="headerlink" title="其它的上下文配置"></a>其它的上下文配置</h2><p>上面所罗列的例子代表了nginx中最基本的上下文配置，在nginx中还存在其它很多可以配置的上下文。</p><h3 id="Upstream上下文配置"><a href="#Upstream上下文配置" class="headerlink" title="Upstream上下文配置"></a>Upstream上下文配置</h3><p>Upstream上下文配置主要用于NGINX的负责均衡能力的配置，先看一下Upstream上下文配置的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    # http context</span><br><span class="line"></span><br><span class="line">    upstream upstream_name &#123;</span><br><span class="line"></span><br><span class="line">        # upstream context</span><br><span class="line"></span><br><span class="line">        server proxy_server1;</span><br><span class="line">        server proxy_server2;</span><br><span class="line"></span><br><span class="line">        . . .</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"></span><br><span class="line">        # server context</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Upstream上下文配置定义了NGINX可以代理请求的服务器池，当我们需要配置各种代理时，就会使用到这个上下文配置。Upstream上下文配置嵌套于Http上下文配置中，和Server上下文配置并列。Upstream上下文配置定义的服务器池可以被Server上下文配置或者Location配置所引用，用于将某种确定类型的请求传递给Upstream上下文配置的服务器池。</p><h3 id="If上下文配置"><a href="#If上下文配置" class="headerlink" title="If上下文配置"></a>If上下文配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax:if (condition) &#123; ... &#125;</span><br><span class="line">Default:—</span><br><span class="line">Context:server, location</span><br></pre></td></tr></table></figure><p>If上下文的配置用来建立在其中定义的指令的条件处理。就像常规编程语言中的if一样，NGINX中的ifc的condition的判断条件为true的时候，“{}”其中的命令会被执行，请求则会被赋值if指令中包含的内容。If上下文配置中可以配置的指令，则继承来自if上下文的父上下文。</p><p>If上下文配置中的condition有以下几种类型：</p><ul><li>一个定义的变量。当这个变量为空string或者值为0的时候，这个condition的值会变回false</li></ul><blockquote><p>在版本1.0.1之前，任何以“0”开头的string condition都会被认为是一个 false 值</p></blockquote><ul><li>使用操作符“=”或者“!=”比较变量和string的值</li><li>判断一个变量是否符合正则表达式（~表示大小写敏感，~<em>表示大小写不敏感）。同时正则表达式可以包含captures(正则表达式中group概念)，captures可以在后续以（$1…$9作为引用的方式来使用）。非操作符如”!~”和“!~</em>”也可以被使用。如果正则表达式配置中包含了”}“或者”;“字符，整个表达式应该被双引号所包裹</li><li>使用”-f”和”!-f“判断一个文件是否存在</li><li>使用”-d”和”!-d”判断一个目录是否存在</li><li>使用”-e”和”!-e”判断一个文件，目录，软连接是否存在</li><li>使用”-x”和”!-x”检查一个可执行文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line">    rewrite ^(.*)$ /msie/$1 break;</span><br><span class="line">&#125;</span><br><span class="line">// 单独解释一下下面的正则</span><br><span class="line">// 括号中的?: 表示正则表达式不会捕捉这个括号中的内容单独作为一个group，比如 “id=([^;]+)(?:;|$)”中的捕捉后分组数为1个</span><br><span class="line">// (:|$) 表示 “冒号”或者“以空为结尾”</span><br><span class="line">if ($http_cookie ~* &quot;id=([^;]+)(?:;|$)&quot;) &#123;</span><br><span class="line">    set $id $1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($request_method = POST) &#123;</span><br><span class="line">    return 405;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($slow) &#123;</span><br><span class="line">    limit_rate 10k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($invalid_referer) &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>If上下文配置的错误使用往往会带来意向不到的后果，参见文章<a href="https://www.nginx.com/resources/wiki/start/topics/depth/ifisevil/" target="_blank" rel="noopener">If is evil</a>,我们在使用的时候，只需要谨记，if不应该应用于大部分形式下的条件执行，在if上下文配置中可以正常使用的是（return）和（rewrite … last;）指令，所以if指令最经常应该使用的场景是用来决定是否需要rewrite或者return操作，这些配置往往出现于location上下文配置中，所以最常见的格式如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// main context</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    # http context</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"></span><br><span class="line">        # server context</span><br><span class="line"></span><br><span class="line">        location location_match &#123;</span><br><span class="line"></span><br><span class="line">            # location context</span><br><span class="line"></span><br><span class="line">            if (test_condition) &#123;</span><br><span class="line"></span><br><span class="line">                # if context</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Limit-except上下文配置"><a href="#Limit-except上下文配置" class="headerlink" title="Limit_except上下文配置"></a>Limit_except上下文配置</h3><p>Limit_except上下文配置嵌套于Location context中，用来控制request请求的HTTP method。举个例子，比如只允许某种特定来源的客户端可以请求POST，其他客户端则只允许GET HEAD, 那么我们就可以这样配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">. . .</span><br><span class="line"></span><br><span class="line">// server or location context</span><br><span class="line"></span><br><span class="line">location /restricted-write &#123;</span><br><span class="line"></span><br><span class="line">    # location context</span><br><span class="line"></span><br><span class="line">    limit_except GET HEAD &#123;</span><br><span class="line"></span><br><span class="line">        # limit_except context</span><br><span class="line"></span><br><span class="line">        allow 192.168.1.1/24;</span><br><span class="line">        deny all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的配置结果是，允许任何的客户端可以发送GET,HEAD请求，同时允许子网为（192.168.1.1/24）的客户端使用其他的请求METHOD.</p><blockquote><p>本文主要总结翻译来源于作者 Justin Ellingwood 的文章，并参考NGINX文档的部分说明。 <a href="https://www.digitalocean.com/community/tutorials/understanding-the-nginx-configuration-file-structure-and-configuration-contexts" target="_blank" rel="noopener">Understanding the Nginx Configuration File Structure and Configuration Contexts</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Nginx作为目前最常使用的异步框架Web服务器, 我们常常将它使用在反向代理， 负载均衡， Http缓存等应用场景。在使用Nginx的时候，我们不可避免地需要去变更NGINX的配置文件来实现我们想要的功能。对于不是很熟悉NGINX配置文件结构的人， 在打开NGINX配置文
      
    
    </summary>
    
    
      <category term="nginx" scheme="http://www.geekiknow.com/tags/nginx/"/>
    
  </entry>
  
</feed>
